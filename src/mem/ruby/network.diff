diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/BasicLink.cc network/BasicLink.cc
59,60d58
<     m_int_node = p->int_node;
<     m_ext_node = p->ext_node;
72,73d69
<     m_node_a = p->node_a;
<     m_node_b = p->node_b;
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/BasicLink.hh network/BasicLink.hh
29,30c29,30
< #ifndef __MEM_RUBY_NETWORK_BASIC_LINK_HH__
< #define __MEM_RUBY_NETWORK_BASIC_LINK_HH__
---
> #ifndef __MEM_RUBY_NETWORK_BASICLINK_HH__
> #define __MEM_RUBY_NETWORK_BASICLINK_HH__
35a36,37
> #include "mem/ruby/network/BasicRouter.hh"
> #include "mem/ruby/slicc_interface/AbstractController.hh"
39,41d40
< #include "mem/ruby/network/BasicRouter.hh"
< #include "mem/ruby/network/Topology.hh"
< #include "mem/ruby/slicc_interface/AbstractController.hh"
43a43,44
> class Topology;
> 
76,79d76
< 
<   protected:
<     BasicRouter* m_int_node;
<     AbstractController* m_ext_node;
90,93d86
< 
<   protected:
<     BasicRouter* m_node_a;
<     BasicRouter* m_node_b;
96c89
< #endif // __MEM_RUBY_NETWORK_BASIC_LINK_HH__
---
> #endif //__MEM_RUBY_NETWORK_BASICLINK_HH__
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/BasicLink.py network/BasicLink.py
38,41c38,40
<     # The following banwidth factor does not translate to the same value for
<     # both the simple and Garnet models.  For the most part, the bandwidth
<     # factor is the width of the link in bytes, expect for certain situations
<     # with regard to the simple network.
---
>     # Width of the link in bytes
>     # Only used by simple network.
>     # Garnet models this by flit size
50c49
<     bandwidth_factor = 16
---
>     bandwidth_factor = 16 # only used by simple network
55,56c54,61
<     node_a = Param.BasicRouter("Router on one end")
<     node_b = Param.BasicRouter("Router on other end")
---
>     src_node = Param.BasicRouter("Router on src end")
>     dst_node = Param.BasicRouter("Router on dst end")
> 
>     # only used by Garnet.
>     src_outport = Param.String("", "Outport direction at src router")
>     dst_inport = Param.String("", "Inport direction at dst router")
> 
>     # only used by simple network
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/BasicRouter.cc network/BasicRouter.cc
34a35
>     m_latency = p->latency;
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/BasicRouter.hh network/BasicRouter.hh
29,30c29,30
< #ifndef __MEM_RUBY_NETWORK_BASIC_ROUTER_HH__
< #define __MEM_RUBY_NETWORK_BASIC_ROUTER_HH__
---
> #ifndef __MEM_RUBY_NETWORK_BASICROUTER_HH__
> #define __MEM_RUBY_NETWORK_BASICROUTER_HH__
53a54
>     uint32_t m_latency;
64c65
< #endif // __MEM_RUBY_NETWORK_BASIC_ROUTER_HH__
---
> #endif //__MEM_RUBY_NETWORK_BASICROUTER_HH__
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/BasicRouter.py network/BasicRouter.py
31c31,32
< from ClockedObject import ClockedObject
---
> 
> from m5.objects.ClockedObject import ClockedObject
36a38,40
> 
>     # only used by garnet
>     latency   = Param.Cycles(1, "number of cycles inside router")
Only in network/: dummy_port.hh
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/fault_model/FaultModel.cc network/fault_model/FaultModel.cc
34c34
<  * If you use our tool for academic research, we request that you cite: 
---
>  * If you use our tool for academic research, we request that you cite:
48c48
< #include "base/misc.hh" 
---
> #include "base/logging.hh"
58c58
<     // format: <buff/vc> <vcs> <10 fault types> 
---
>     // format: <buff/vc> <vcs> <10 fault types>
62c62
<         configuration.buff_per_vc = 
---
>         configuration.buff_per_vc =
64c64
<         configuration.vcs = 
---
>         configuration.vcs =
66c66
<         for (int fault_index = 0; fault_index < number_of_fault_types; 
---
>         for (int fault_index = 0; fault_index < number_of_fault_types;
68,69c68,69
<             configuration.fault_type[fault_index] = 
<                 p->baseline_fault_vector_database[i + 
---
>             configuration.fault_type[fault_index] =
>                 p->baseline_fault_vector_database[i +
82c82
<         int record_temperature = 
---
>         int record_temperature =
88c88
<             for (int temperature = 0; temperature < record_temperature; 
---
>             for (int temperature = 0; temperature < record_temperature;
96c96
<         if (p->temperature_weights_database[i + 
---
>         if (p->temperature_weights_database[i +
134,138c134,138
< int 
< FaultModel::declare_router(int number_of_inputs, 
<                            int number_of_outputs, 
<                            int number_of_vcs_per_input, 
<                            int number_of_buff_per_data_vc, 
---
> int
> FaultModel::declare_router(int number_of_inputs,
>                            int number_of_outputs,
>                            int number_of_vcs_per_input,
>                            int number_of_buff_per_data_vc,
143c143
<         number_of_vcs_per_input <= 0 || number_of_buff_per_data_vc <= 0 || 
---
>         number_of_vcs_per_input <= 0 || number_of_buff_per_data_vc <= 0 ||
159c159
<     for (int record = 0; record < configurations.size(); record++){    
---
>     for (int record = 0; record < configurations.size(); record++){
175,176c175,176
< bool 
< FaultModel::fault_vector(int routerID, 
---
> bool
> FaultModel::fault_vector(int routerID,
185c185
<         fatal("Fault Model: Did you enable the fault model flag)?");     
---
>         fatal("Fault Model: Did you enable the fault model flag)?");
204c204
<         fault_vector[i] = routers[routerID].fault_type[i] * 
---
>         fault_vector[i] = routers[routerID].fault_type[i] *
210,211c210,211
< bool 
< FaultModel::fault_prob(int routerID, 
---
> bool
> FaultModel::fault_prob(int routerID,
221c221
<         fatal("Fault Model: Did you enable the fault model flag)?");     
---
>         fatal("Fault Model: Did you enable the fault model flag)?");
240,241c240,241
<         *aggregate_fault_prob=  *aggregate_fault_prob * 
<                                ( 1.0 - (routers[routerID].fault_type[i] * 
---
>         *aggregate_fault_prob=  *aggregate_fault_prob *
>                                ( 1.0 - (routers[routerID].fault_type[i] *
249c249
< void 
---
> void
257,258c257,258
<         for (int fault_type_num = 0; 
<              fault_type_num < number_of_fault_types; 
---
>         for (int fault_type_num = 0;
>              fault_type_num < number_of_fault_types;
260c260
<             cout << (100 * configurations[record].fault_type[fault_type_num]); 
---
>             cout << (100 * configurations[record].fault_type[fault_type_num]);
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/fault_model/FaultModel.hh network/fault_model/FaultModel.hh
34c34
<  * If you use our tool for academic research, we request that you cite: 
---
>  * If you use our tool for academic research, we request that you cite:
40,41c40,41
< #ifndef __MEM_RUBY_NETWORK_FAULT_MODEL_HH__
< #define __MEM_RUBY_NETWORK_FAULT_MODEL_HH__
---
> #ifndef __MEM_RUBY_NETWORK_FAULT_MODEL_FAULTMODEL_HH__
> #define __MEM_RUBY_NETWORK_FAULT_MODEL_FAULTMODEL_HH__
66c66
<     enum fault_type 
---
>     enum fault_type
108,111c108,111
<     int declare_router(int number_of_inputs, 
<                        int number_of_outputs, 
<                        int number_of_vcs_per_vnet, 
<                        int number_of_buff_per_data_vc, 
---
>     int declare_router(int number_of_inputs,
>                        int number_of_outputs,
>                        int number_of_vcs_per_vnet,
>                        int number_of_buff_per_data_vc,
115,117c115,117
<  
<     // the following 2 functions are called at runtime, to get the probability 
<     // of each fault type (fault_vector) or the aggregate fault probability 
---
> 
>     // the following 2 functions are called at runtime, to get the probability
>     // of each fault type (fault_vector) or the aggregate fault probability
120c120
<     // Both functions also return a success flag (which is always true if 
---
>     // Both functions also return a success flag (which is always true if
123,124c123,124
<     bool fault_vector(int routerID, 
<                       int temperature, 
---
>     bool fault_vector(int routerID,
>                       int temperature,
128c128
<                     int temperature, 
---
>                     int temperature,
141c141
< #endif //  __MEM_RUBY_NETWORK_FAULT_MODEL_HH__
---
> #endif //__MEM_RUBY_NETWORK_FAULT_MODEL_FAULTMODEL_HH__
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/fault_model/FaultModel.py network/fault_model/FaultModel.py
31c31
< # If you use our tool for academic research, we request that you cite: 
---
> # If you use our tool for academic research, we request that you cite:
41c41
<     cxx_class = 'FaultModel' 
---
>     cxx_class = 'FaultModel'
43c43
<     
---
> 
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/fault_model/SConscript network/fault_model/SConscript
31c31
< # If you use our tool for academic research, we request that you cite: 
---
> # If you use our tool for academic research, we request that you cite:
Only in /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/: garnet
Only in network/: garnet2.0
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/MessageBuffer.cc network/MessageBuffer.cc
28a29,30
> #include "mem/ruby/network/MessageBuffer.hh"
> 
32c34
< #include "base/misc.hh"
---
> #include "base/logging.hh"
36,37c38
< #include "mem/ruby/network/MessageBuffer.hh"
< #include "mem/ruby/system/System.hh"
---
> #include "mem/ruby/system/RubySystem.hh"
43c44
<     : SimObject(p), m_recycle_latency(p->recycle_latency),
---
>     : SimObject(p), m_stall_map_size(0),
51,53d51
<     m_sender = NULL;
<     m_receiver = NULL;
< 
55a54
>     m_stalled_at_cycle_start = 0;
57d55
<     m_not_avail_count = 0;
62a61,65
> 
>     m_buf_msgs = 0;
>     m_stall_time = 0;
> 
>     m_dequeue_callback = nullptr;
66c69
< MessageBuffer::getSize()
---
> MessageBuffer::getSize(Tick curTime)
68,69c71,72
<     if (m_time_last_time_size_checked != m_receiver->curCycle()) {
<         m_time_last_time_size_checked = m_receiver->curCycle();
---
>     if (m_time_last_time_size_checked != curTime) {
>         m_time_last_time_size_checked = curTime;
77c80
< MessageBuffer::areNSlotsAvailable(unsigned int n)
---
> MessageBuffer::areNSlotsAvailable(unsigned int n, Tick current_time)
89a93
>     unsigned int current_stall_size = 0;
91,92c95,96
<     if (m_time_last_time_pop < m_sender->clockEdge()) {
<         // no pops this cycle - heap size is correct
---
>     if (m_time_last_time_pop < current_time) {
>         // no pops this cycle - heap and stall queue size is correct
93a98
>         current_stall_size = m_stall_map_size;
95c100
<         if (m_time_last_time_enqueue < m_sender->curCycle()) {
---
>         if (m_time_last_time_enqueue < current_time) {
102a108,110
> 
>         // Stall queue size at start is considered
>         current_stall_size = m_stalled_at_cycle_start;
106c114
<     if (current_size + n <= m_max_size) {
---
>     if (current_size + current_stall_size + n <= m_max_size) {
111c119,120
<                 n, current_size, m_prio_heap.size(), m_max_size);
---
>                 n, current_size + current_stall_size,
>                 m_prio_heap.size(), m_max_size);
121,122d129
<     assert(isReady());
< 
131c138
< Cycles
---
> Tick
134,135c141,142
<     Cycles time(1);
<     time += Cycles(random_mt.random(0, 3));  // [0...3]
---
>     Tick time = 1;
>     time += random_mt.random(0, 3);  // [0...3]
137c144
<         time += Cycles(100 + random_mt.random(1, 15)); // 100 + [1...15]
---
>         time += 100 + random_mt.random(1, 15); // 100 + [1...15]
143c150
< MessageBuffer::enqueue(MsgPtr message, Cycles delta)
---
> MessageBuffer::enqueue(MsgPtr message, Tick current_time, Tick delta)
146c153
<     if (m_time_last_time_enqueue < m_sender->curCycle()) {
---
>     if (m_time_last_time_enqueue < current_time) {
148c155
<         m_time_last_time_enqueue = m_sender->curCycle();
---
>         m_time_last_time_enqueue = current_time;
157d163
<     Tick current_time = m_sender->clockEdge();
160c166,168
<     if (!RubySystem::getRandomization() || !m_randomization) {
---
>     // random delays are inserted if either RubySystem level randomization flag
>     // is turned on, or the buffer level randomization is set
>     if (!RubySystem::getRandomization() && !m_randomization) {
162c170
<         arrival_time = current_time + delta * m_sender->clockPeriod();
---
>         arrival_time = current_time + delta;
169,170c177
<             arrival_time = m_last_arrival_time +
<                            random_time() * m_sender->clockPeriod();
---
>             arrival_time = m_last_arrival_time + random_time();
172,173c179
<             arrival_time = current_time +
<                            random_time() * m_sender->clockPeriod();
---
>             arrival_time = current_time + random_time();
183,185c189,190
<                   *this, name(), current_time,
<                   delta * m_sender->clockPeriod(),
<                   arrival_time, m_last_arrival_time);
---
>                   *this, name(), current_time, delta, arrival_time,
>                   m_last_arrival_time);
198c203
<     assert(m_sender->clockEdge() >= msg_ptr->getLastEnqueueTime() &&
---
>     assert(current_time >= msg_ptr->getLastEnqueueTime() &&
201c206
<     msg_ptr->updateDelayedTicks(m_sender->clockEdge());
---
>     msg_ptr->updateDelayedTicks(current_time);
207a213,214
>     // Increment the number of messages statistic
>     m_buf_msgs++;
218,219c225,226
< Cycles
< MessageBuffer::dequeue()
---
> Tick
> MessageBuffer::dequeue(Tick current_time, bool decrement_messages)
222c229
<     assert(isReady());
---
>     assert(isReady(current_time));
228,230c235,238
<     message->updateDelayedTicks(m_receiver->clockEdge());
<     Cycles delayCycles =
<         m_receiver->ticksToCycles(message->getDelayedTicks());
---
>     message->updateDelayedTicks(current_time);
>     Tick delay = message->getDelayedTicks();
> 
>     m_stall_time = curTick() - message->getTime();
234c242
<     if (m_time_last_time_pop < m_receiver->clockEdge()) {
---
>     if (m_time_last_time_pop < current_time) {
236c244,245
<         m_time_last_time_pop = m_receiver->clockEdge();
---
>         m_stalled_at_cycle_start = m_stall_map_size;
>         m_time_last_time_pop = current_time;
239,240c248
<     pop_heap(m_prio_heap.begin(), m_prio_heap.end(),
<         greater<MsgPtr>());
---
>     pop_heap(m_prio_heap.begin(), m_prio_heap.end(), greater<MsgPtr>());
241a250,268
>     if (decrement_messages) {
>         // If the message will be removed from the queue, decrement the
>         // number of message in the queue.
>         m_buf_msgs--;
>     }
> 
>     // if a dequeue callback was requested, call it now
>     if (m_dequeue_callback) {
>         m_dequeue_callback();
>     }
> 
>     return delay;
> }
> 
> void
> MessageBuffer::registerDequeueCallback(std::function<void()> callback)
> {
>     m_dequeue_callback = callback;
> }
243c270,273
<     return delayCycles;
---
> void
> MessageBuffer::unregisterDequeueCallback()
> {
>     m_dequeue_callback = nullptr;
252c282
<     m_time_last_time_enqueue = Cycles(0);
---
>     m_time_last_time_enqueue = 0;
254a285
>     m_stalled_at_cycle_start = 0;
259c290
< MessageBuffer::recycle()
---
> MessageBuffer::recycle(Tick current_time, Tick recycle_latency)
262c293
<     assert(isReady());
---
>     assert(isReady(current_time));
266c297,299
<     node->setLastEnqueueTime(m_receiver->clockEdge(m_recycle_latency));
---
>     Tick future_time = current_time + recycle_latency;
>     node->setLastEnqueueTime(future_time);
> 
269,270c302
<     m_consumer->
<         scheduleEventAbsolute(m_receiver->clockEdge(m_recycle_latency));
---
>     m_consumer->scheduleEventAbsolute(future_time);
276,277c308
<     while(!lt.empty()) {
<         m_msg_counter++;
---
>     while (!lt.empty()) {
279,280c310
<         m->setLastEnqueueTime(schdTick);
<         m->setMsgCounter(m_msg_counter);
---
>         assert(m->getLastEnqueueTime() <= schdTick);
286a317,320
> 
>         DPRINTF(RubyQueue, "Requeue arrival_time: %lld, Message: %s\n",
>             schdTick, *(m.get()));
> 
292c326
< MessageBuffer::reanalyzeMessages(Addr addr)
---
> MessageBuffer::reanalyzeMessages(Addr addr, Tick current_time)
294c328
<     DPRINTF(RubyQueue, "ReanalyzeMessages %s\n", addr);
---
>     DPRINTF(RubyQueue, "ReanalyzeMessages %#x\n", addr);
296d329
<     Tick curTick = m_receiver->clockEdge();
304c337,339
<     reanalyzeList(m_stall_msg_map[addr], curTick);
---
>     m_stall_map_size -= m_stall_msg_map[addr].size();
>     assert(m_stall_map_size >= 0);
>     reanalyzeList(m_stall_msg_map[addr], current_time);
309c344
< MessageBuffer::reanalyzeAllMessages()
---
> MessageBuffer::reanalyzeAllMessages(Tick current_time)
312d346
<     Tick curTick = m_receiver->clockEdge();
322c356,358
<         reanalyzeList(map_iter->second, curTick);
---
>         m_stall_map_size -= map_iter->second.size();
>         assert(m_stall_map_size >= 0);
>         reanalyzeList(map_iter->second, current_time);
328c364
< MessageBuffer::stallMessage(Addr addr)
---
> MessageBuffer::stallMessage(Addr addr, Tick current_time)
330,331c366,367
<     DPRINTF(RubyQueue, "Stalling due to %s\n", addr);
<     assert(isReady());
---
>     DPRINTF(RubyQueue, "Stalling due to %#x\n", addr);
>     assert(isReady(current_time));
335c371,373
<     dequeue();
---
>     // Since the message will just be moved to stall map, indicate that the
>     // buffer should not decrement the m_buf_msgs statistic
>     dequeue(current_time, false);
342a381,382
>     m_stall_map_size++;
>     m_stall_count++;
359c399
< MessageBuffer::isReady() const
---
> MessageBuffer::isReady(Tick current_time) const
362c402
<         (m_prio_heap.front()->getLastEnqueueTime() <= m_receiver->clockEdge()));
---
>         (m_prio_heap.front()->getLastEnqueueTime() <= current_time));
365,366c405,406
< bool
< MessageBuffer::functionalRead(Packet *pkt)
---
> void
> MessageBuffer::regStats()
368,382c408,431
<     // Check the priority heap and read any messages that may
<     // correspond to the address in the packet.
<     for (unsigned int i = 0; i < m_prio_heap.size(); ++i) {
<         Message *msg = m_prio_heap[i].get();
<         if (msg->functionalRead(pkt)) return true;
<     }
< 
<     // Read the messages in the stall queue that correspond
<     // to the address in the packet.
<     for (StallMsgMapType::iterator map_iter = m_stall_msg_map.begin();
<          map_iter != m_stall_msg_map.end();
<          ++map_iter) {
< 
<         for (std::list<MsgPtr>::iterator it = (map_iter->second).begin();
<             it != (map_iter->second).end(); ++it) {
---
>     m_not_avail_count
>         .name(name() + ".not_avail_count")
>         .desc("Number of times this buffer did not have N slots available")
>         .flags(Stats::nozero);
> 
>     m_buf_msgs
>         .name(name() + ".avg_buf_msgs")
>         .desc("Average number of messages in buffer")
>         .flags(Stats::nozero);
> 
>     m_stall_count
>         .name(name() + ".num_msg_stalls")
>         .desc("Number of times messages were stalled")
>         .flags(Stats::nozero);
> 
>     m_occupancy
>         .name(name() + ".avg_buf_occ")
>         .desc("Average occupancy of buffer capacity")
>         .flags(Stats::nozero);
> 
>     m_stall_time
>         .name(name() + ".avg_stall_time")
>         .desc("Average number of cycles messages are stalled in this MB")
>         .flags(Stats::nozero);
384,386c433,436
<             Message *msg = (*it).get();
<             if (msg->functionalRead(pkt)) return true;
<         }
---
>     if (m_max_size > 0) {
>         m_occupancy = m_buf_msgs / m_max_size;
>     } else {
>         m_occupancy = 0;
388d437
<     return false;
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/MessageBuffer.hh network/MessageBuffer.hh
34,35c34,35
< #ifndef __MEM_RUBY_BUFFERS_MESSAGEBUFFER_HH__
< #define __MEM_RUBY_BUFFERS_MESSAGEBUFFER_HH__
---
> #ifndef __MEM_RUBY_NETWORK_MESSAGEBUFFER_HH__
> #define __MEM_RUBY_NETWORK_MESSAGEBUFFER_HH__
43a44
> #include "base/trace.hh"
44a46,47
> #include "mem/packet.hh"
> #include "mem/port.hh"
46a50
> #include "mem/ruby/network/dummy_port.hh"
48d51
< #include "mem/packet.hh"
58,60c61,63
<     void reanalyzeMessages(Addr addr);
<     void reanalyzeAllMessages();
<     void stallMessage(Addr addr);
---
>     void reanalyzeMessages(Addr addr, Tick current_time);
>     void reanalyzeAllMessages(Tick current_time);
>     void stallMessage(Addr addr, Tick current_time);
63c66
<     bool isReady() const;
---
>     bool isReady(Tick current_time) const;
66c69
<     delayHead()
---
>     delayHead(Tick current_time, Tick delta)
72c75
<         enqueue(m, Cycles(1));
---
>         enqueue(m, current_time, delta);
75c78
<     bool areNSlotsAvailable(unsigned int n);
---
>     bool areNSlotsAvailable(unsigned int n, Tick curTime);
89,102d91
<     void setSender(ClockedObject* obj)
<     {
<         DPRINTF(RubyQueue, "Setting sender: %s\n", obj->name());
<         assert(m_sender == NULL || m_sender == obj);
<         m_sender = obj;
<     }
< 
<     void setReceiver(ClockedObject* obj)
<     {
<         DPRINTF(RubyQueue, "Setting receiver: %s\n", obj->name());
<         assert(m_receiver == NULL || m_receiver == obj);
<         m_receiver = obj;
<     }
< 
111,116c100
<     const MsgPtr&
<     peekMsgPtr() const
<     {
<         assert(isReady());
<         return m_prio_heap.front();
<     }
---
>     const MsgPtr &peekMsgPtr() const { return m_prio_heap.front(); }
118,119c102
<     void enqueue(MsgPtr message) { enqueue(message, Cycles(1)); }
<     void enqueue(MsgPtr message, Cycles delta);
---
>     void enqueue(MsgPtr message, Tick curTime, Tick delta);
123c106
<     Cycles dequeue();
---
>     Tick dequeue(Tick current_time, bool decrement_messages = true);
125c108,111
<     void recycle();
---
>     void registerDequeueCallback(std::function<void()> callback);
>     void unregisterDequeueCallback();
> 
>     void recycle(Tick current_time, Tick recycle_latency);
130c116
<     unsigned int getSize();
---
>     unsigned int getSize(Tick curTime);
139,142c125,131
<     // Function for figuring out if any of the messages in the buffer can
<     // satisfy the read request for the address in the packet.
<     // Return value, if true, indicates that the request was fulfilled.
<     bool functionalRead(Packet *pkt);
---
>     Port &
>     getPort(const std::string &, PortID idx=InvalidPortID) override
>     {
>         return RubyDummyPort::instance();
>     }
> 
>     void regStats() override;
151,153d139
<     //added by SS
<     const Cycles m_recycle_latency;
< 
158,161d143
<     //! The two ends of the buffer.
<     ClockedObject* m_sender;
<     ClockedObject* m_receiver;
< 
165a148,149
>     std::function<void()> m_dequeue_callback;
> 
169a154,166
>     /**
>      * A map from line addresses to lists of stalled messages for that line.
>      * If this buffer allows the receiver to stall messages, on a stall
>      * request, the stalled message is removed from the m_prio_heap and placed
>      * in the m_stall_msg_map. Messages are held there until the receiver
>      * requests they be reanalyzed, at which point they are moved back to
>      * m_prio_heap.
>      *
>      * NOTE: The stall map holds messages in the order in which they were
>      * initially received, and when a line is unblocked, the messages are
>      * moved back to the m_prio_heap in the same order. This prevents starving
>      * older requests with younger ones.
>      */
171a169,182
>     /**
>      * Current size of the stall map.
>      * Track the number of messages held in stall map lists. This is used to
>      * ensure that if the buffer is finite-sized, it blocks further requests
>      * when the m_prio_heap and m_stall_msg_map contain m_max_size messages.
>      */
>     int m_stall_map_size;
> 
>     /**
>      * The maximum capacity. For finite-sized buffers, m_max_size stores a
>      * number greater than 0 to indicate the maximum allowed number of messages
>      * in the buffer at any time. To get infinitely-sized buffers, set buffer
>      * size: m_max_size = 0
>      */
173c184,185
<     Cycles m_time_last_time_size_checked;
---
> 
>     Tick m_time_last_time_size_checked;
178c190
<     Cycles m_time_last_time_enqueue;
---
>     Tick m_time_last_time_enqueue;
182a195
>     unsigned int m_stalled_at_cycle_start;
185,186c198,199
<     int m_not_avail_count;  // count the # of times I didn't have N
<                             // slots available
---
>     Stats::Scalar m_not_avail_count;  // count the # of times I didn't have N
>                                       // slots available
193a207,211
> 
>     Stats::Average m_buf_msgs;
>     Stats::Average m_stall_time;
>     Stats::Scalar m_stall_count;
>     Stats::Formula m_occupancy;
196c214
< Cycles random_time();
---
> Tick random_time();
206c224
< #endif // __MEM_RUBY_BUFFERS_MESSAGEBUFFER_HH__
---
> #endif //__MEM_RUBY_NETWORK_MESSAGEBUFFER_HH__
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/MessageBuffer.py network/MessageBuffer.py
40,41c40,43
<     recycle_latency = Param.Cycles(Parent.recycle_latency, "")
<     randomization = Param.Bool(False, "")
---
>     randomization = Param.Bool(False, "Insert random delays on message \
>                                        enqueue times (enforced to have \
>                                        random delays if RubySystem \
>                                        randomization flag is True)")
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/Network.cc network/Network.cc
1a2,13
>  * Copyright (c) 2017 ARM Limited
>  * All rights reserved.
>  *
>  * The license below extends only to copyright in the software and shall
>  * not be construed as granting a license to any other intellectual
>  * property including but not limited to intellectual property relating
>  * to a hardware implementation of the functionality of the software
>  * licensed hereunder.  You may use the software subject to the license
>  * terms below provided that you ensure that this notice is replicated
>  * unmodified and in its entirety in all distributions of the software,
>  * modified or unmodified, in source code or in binary form.
>  *
29,30d40
< #include "base/misc.hh"
< #include "mem/ruby/network/BasicLink.hh"
32c42,46
< #include "mem/ruby/system/System.hh"
---
> 
> #include "base/logging.hh"
> #include "mem/ruby/common/MachineID.hh"
> #include "mem/ruby/network/BasicLink.hh"
> #include "mem/ruby/system/RubySystem.hh"
60d73
<     m_in_use.resize(m_virtual_networks);
61a75
>     m_vnet_type_names.resize(m_virtual_networks);
64d77
<         m_in_use[i] = false;
75a89,97
>         const AddrRangeList &ranges = abs_cntrl->getAddrRanges();
>         if (!ranges.empty()) {
>             MachineID mid = abs_cntrl->getMachineID();
>             AddrMapNode addr_map_node = {
>                 .id = mid.getNum(),
>                 .ranges = ranges
>             };
>             addrMap.emplace(mid.getType(), addr_map_node);
>         }
79a102,105
> 
>     for (auto &it : dynamic_cast<Network *>(this)->params()->ext_links) {
>         it->params()->ext_node->initNetQueues();
>     }
131a158,213
> }
> 
> void
> Network::checkNetworkAllocation(NodeID id, bool ordered,
>                                         int network_num,
>                                         std::string vnet_type)
> {
>     fatal_if(id >= m_nodes, "Node ID is out of range");
>     fatal_if(network_num >= m_virtual_networks, "Network id is out of range");
> 
>     if (ordered) {
>         m_ordered[network_num] = true;
>     }
> 
>     m_vnet_type_names[network_num] = vnet_type;
> }
> 
> 
> void
> Network::setToNetQueue(NodeID id, bool ordered, int network_num,
>                                  std::string vnet_type, MessageBuffer *b)
> {
>     checkNetworkAllocation(id, ordered, network_num, vnet_type);
>     while (m_toNetQueues[id].size() <= network_num) {
>         m_toNetQueues[id].push_back(nullptr);
>     }
>     m_toNetQueues[id][network_num] = b;
> }
> 
> void
> Network::setFromNetQueue(NodeID id, bool ordered, int network_num,
>                                    std::string vnet_type, MessageBuffer *b)
> {
>     checkNetworkAllocation(id, ordered, network_num, vnet_type);
>     while (m_fromNetQueues[id].size() <= network_num) {
>         m_fromNetQueues[id].push_back(nullptr);
>     }
>     m_fromNetQueues[id][network_num] = b;
> }
> 
> NodeID
> Network::addressToNodeID(Addr addr, MachineType mtype)
> {
>     // Look through the address maps for entries with matching machine
>     // type to get the responsible node for this address.
>     const auto &matching_ranges = addrMap.equal_range(mtype);
>     for (auto it = matching_ranges.first; it != matching_ranges.second; it++) {
>         AddrMapNode &node = it->second;
>         auto &ranges = node.ranges;
>         for (AddrRange &range: ranges) {
>             if (range.contains(addr)) {
>                 return node.id;
>             }
>         }
>     }
>     return MachineType_base_count(mtype);
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/Network.hh network/Network.hh
1a2,13
>  * Copyright (c) 2017 ARM Limited
>  * All rights reserved.
>  *
>  * The license below extends only to copyright in the software and shall
>  * not be construed as granting a license to any other intellectual
>  * property including but not limited to intellectual property relating
>  * to a hardware implementation of the functionality of the software
>  * licensed hereunder.  You may use the software subject to the license
>  * terms below provided that you ensure that this notice is replicated
>  * unmodified and in its entirety in all distributions of the software,
>  * modified or unmodified, in source code or in binary form.
>  *
44a57
> #include <unordered_map>
47,48c60,64
< #include "mem/protocol/LinkDirection.hh"
< #include "mem/protocol/MessageSizeType.hh"
---
> #include "base/addr_range.hh"
> #include "base/types.hh"
> #include "mem/packet.hh"
> #include "mem/port.hh"
> #include "mem/ruby/common/MachineID.hh"
51c67,69
< #include "mem/packet.hh"
---
> #include "mem/ruby/network/dummy_port.hh"
> #include "mem/ruby/protocol/LinkDirection.hh"
> #include "mem/ruby/protocol/MessageSizeType.hh"
67c85
<     virtual void init();
---
>     void init() override;
75,76c93,94
<     virtual void setToNetQueue(NodeID id, bool ordered, int netNumber,
<                                std::string vnet_type, MessageBuffer *b) = 0;
---
>     void setToNetQueue(NodeID id, bool ordered, int netNumber,
>                                std::string vnet_type, MessageBuffer *b);
78c96,99
<                                  std::string vnet_type, MessageBuffer *b) = 0;
---
>                                  std::string vnet_type, MessageBuffer *b);
> 
>     virtual void checkNetworkAllocation(NodeID id, bool ordered,
>         int network_num, std::string vnet_type);
80,81c101
<     virtual void makeOutLink(SwitchID src, NodeID dest, BasicLink* link,
<                              LinkDirection direction,
---
>     virtual void makeExtOutLink(SwitchID src, NodeID dest, BasicLink* link,
83,84c103
<     virtual void makeInLink(NodeID src, SwitchID dest, BasicLink* link,
<                             LinkDirection direction,
---
>     virtual void makeExtInLink(NodeID src, SwitchID dest, BasicLink* link,
87,88c106,108
<                                   LinkDirection direction,
<                                   const NetDest& routing_table_entry) = 0;
---
>                                   const NetDest& routing_table_entry,
>                                   PortDirection src_outport,
>                                   PortDirection dst_inport) = 0;
102a123,142
>     /**
>      * Map an address to the correct NodeID
>      *
>      * This function traverses the global address map to find the
>      * NodeID that corresponds to the given address and the type of
>      * the destination. For example for a request to a directory this
>      * function will return the NodeID of the right directory.
>      *
>      * @param the destination address
>      * @param the type of the destination
>      * @return the NodeID of the destination
>      */
>     NodeID addressToNodeID(Addr addr, MachineType mtype);
> 
>     Port &
>     getPort(const std::string &, PortID idx=InvalidPortID) override
>     {
>         return RubyDummyPort::instance();
>     }
> 
109a150
>     std::vector<std::string> m_vnet_type_names;
117,118d157
< 
<     std::vector<bool> m_in_use;
138a178,184
> 
>     // Global address map
>     struct AddrMapNode {
>         NodeID id;
>         AddrRangeList ranges;
>     };
>     std::unordered_multimap<MachineType, AddrMapNode> addrMap;
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/Network.py network/Network.py
31,32c31,32
< from ClockedObject import ClockedObject
< from BasicLink import BasicLink
---
> from m5.objects.ClockedObject import ClockedObject
> from m5.objects.BasicLink import BasicLink
42c42,46
<     number_of_virtual_networks = Param.Int(10, "")
---
>     number_of_virtual_networks = Param.Unsigned("Number of virtual networks "
>            "used by the coherence protocol in use.  The on-chip network "
>            "assumes the protocol numbers vnets starting from 0.  Therefore, "
>            "the number of virtual networks should be one more than the "
>            "highest numbered vnet in use.")
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/PerfectSwitch.cc network/simple/PerfectSwitch.cc
28a29,30
> #include "mem/ruby/network/simple/PerfectSwitch.hh"
> 
35d36
< #include "mem/ruby/network/simple/PerfectSwitch.hh"
52c53
<     : Consumer(sw)
---
>     : Consumer(sw), m_switch_id(sid), m_switch(sw)
54d54
<     m_switch_id = sid;
65c65
<     for(int i = 0;i < m_virtual_networks;++i) {
---
>     for (int i = 0;i < m_virtual_networks;++i) {
107,109d106
<     MsgPtr msg_ptr;
<     Message *net_msg_ptr = NULL;
< 
117c114
<     if(m_pending_message_count[vnet] > 0) {
---
>     if (m_pending_message_count[vnet] > 0) {
126,129d122
<             // temporary vectors to store the routing results
<             vector<LinkID> output_links;
<             vector<NetDest> output_link_destinations;
< 
140,141c133,136
<             while (buffer->isReady()) {
<                 DPRINTF(RubyNetwork, "incoming: %d\n", incoming);
---
>             operateMessageBuffer(buffer, incoming, vnet);
>         }
>     }
> }
143,178c138,143
<                 // Peek at message
<                 msg_ptr = buffer->peekMsgPtr();
<                 net_msg_ptr = msg_ptr.get();
<                 DPRINTF(RubyNetwork, "Message: %s\n", (*net_msg_ptr));
< 
<                 output_links.clear();
<                 output_link_destinations.clear();
<                 NetDest msg_dsts = net_msg_ptr->getDestination();
< 
<                 // Unfortunately, the token-protocol sends some
<                 // zero-destination messages, so this assert isn't valid
<                 // assert(msg_dsts.count() > 0);
< 
<                 assert(m_link_order.size() == m_routing_table.size());
<                 assert(m_link_order.size() == m_out.size());
< 
<                 if (m_network_ptr->getAdaptiveRouting()) {
<                     if (m_network_ptr->isVNetOrdered(vnet)) {
<                         // Don't adaptively route
<                         for (int out = 0; out < m_out.size(); out++) {
<                             m_link_order[out].m_link = out;
<                             m_link_order[out].m_value = 0;
<                         }
<                     } else {
<                         // Find how clogged each link is
<                         for (int out = 0; out < m_out.size(); out++) {
<                             int out_queue_length = 0;
<                             for (int v = 0; v < m_virtual_networks; v++) {
<                                 out_queue_length += m_out[out][v]->getSize();
<                             }
<                             int value =
<                                 (out_queue_length << 8) |
<                                 random_mt.random(0, 0xff);
<                             m_link_order[out].m_link = out;
<                             m_link_order[out].m_value = value;
<                         }
---
> void
> PerfectSwitch::operateMessageBuffer(MessageBuffer *buffer, int incoming,
>                                     int vnet)
> {
>     MsgPtr msg_ptr;
>     Message *net_msg_ptr = NULL;
180,181c145,181
<                         // Look at the most empty link first
<                         sort(m_link_order.begin(), m_link_order.end());
---
>     // temporary vectors to store the routing results
>     vector<LinkID> output_links;
>     vector<NetDest> output_link_destinations;
>     Tick current_time = m_switch->clockEdge();
> 
>     while (buffer->isReady(current_time)) {
>         DPRINTF(RubyNetwork, "incoming: %d\n", incoming);
> 
>         // Peek at message
>         msg_ptr = buffer->peekMsgPtr();
>         net_msg_ptr = msg_ptr.get();
>         DPRINTF(RubyNetwork, "Message: %s\n", (*net_msg_ptr));
> 
>         output_links.clear();
>         output_link_destinations.clear();
>         NetDest msg_dsts = net_msg_ptr->getDestination();
> 
>         // Unfortunately, the token-protocol sends some
>         // zero-destination messages, so this assert isn't valid
>         // assert(msg_dsts.count() > 0);
> 
>         assert(m_link_order.size() == m_routing_table.size());
>         assert(m_link_order.size() == m_out.size());
> 
>         if (m_network_ptr->getAdaptiveRouting()) {
>             if (m_network_ptr->isVNetOrdered(vnet)) {
>                 // Don't adaptively route
>                 for (int out = 0; out < m_out.size(); out++) {
>                     m_link_order[out].m_link = out;
>                     m_link_order[out].m_value = 0;
>                 }
>             } else {
>                 // Find how clogged each link is
>                 for (int out = 0; out < m_out.size(); out++) {
>                     int out_queue_length = 0;
>                     for (int v = 0; v < m_virtual_networks; v++) {
>                         out_queue_length += m_out[out][v]->getSize(current_time);
182a183,187
>                     int value =
>                         (out_queue_length << 8) |
>                         random_mt.random(0, 0xff);
>                     m_link_order[out].m_link = out;
>                     m_link_order[out].m_value = value;
185,206c190,193
<                 for (int i = 0; i < m_routing_table.size(); i++) {
<                     // pick the next link to look at
<                     int link = m_link_order[i].m_link;
<                     NetDest dst = m_routing_table[link];
<                     DPRINTF(RubyNetwork, "dst: %s\n", dst);
< 
<                     if (!msg_dsts.intersectionIsNotEmpty(dst))
<                         continue;
< 
<                     // Remember what link we're using
<                     output_links.push_back(link);
< 
<                     // Need to remember which destinations need this message in
<                     // another vector.  This Set is the intersection of the
<                     // routing_table entry and the current destination set.  The
<                     // intersection must not be empty, since we are inside "if"
<                     output_link_destinations.push_back(msg_dsts.AND(dst));
< 
<                     // Next, we update the msg_destination not to include
<                     // those nodes that were already handled by this link
<                     msg_dsts.removeNetDest(dst);
<                 }
---
>                 // Look at the most empty link first
>                 sort(m_link_order.begin(), m_link_order.end());
>             }
>         }
208c195,199
<                 assert(msg_dsts.count() == 0);
---
>         for (int i = 0; i < m_routing_table.size(); i++) {
>             // pick the next link to look at
>             int link = m_link_order[i].m_link;
>             NetDest dst = m_routing_table[link];
>             DPRINTF(RubyNetwork, "dst: %s\n", dst);
210,221c201,202
<                 // Check for resources - for all outgoing queues
<                 bool enough = true;
<                 for (int i = 0; i < output_links.size(); i++) {
<                     int outgoing = output_links[i];
< 
<                     if (!m_out[outgoing][vnet]->areNSlotsAvailable(1))
<                         enough = false;
< 
<                     DPRINTF(RubyNetwork, "Checking if node is blocked ..."
<                             "outgoing: %d, vnet: %d, enough: %d\n",
<                             outgoing, vnet, enough);
<                 }
---
>             if (!msg_dsts.intersectionIsNotEmpty(dst))
>                 continue;
223,230c204,205
<                 // There were not enough resources
<                 if (!enough) {
<                     scheduleEvent(Cycles(1));
<                     DPRINTF(RubyNetwork, "Can't deliver message since a node "
<                             "is blocked\n");
<                     DPRINTF(RubyNetwork, "Message: %s\n", (*net_msg_ptr));
<                     break; // go to next incoming port
<                 }
---
>             // Remember what link we're using
>             output_links.push_back(link);
232c207,216
<                 MsgPtr unmodified_msg_ptr;
---
>             // Need to remember which destinations need this message in
>             // another vector.  This Set is the intersection of the
>             // routing_table entry and the current destination set.  The
>             // intersection must not be empty, since we are inside "if"
>             output_link_destinations.push_back(msg_dsts.AND(dst));
> 
>             // Next, we update the msg_destination not to include
>             // those nodes that were already handled by this link
>             msg_dsts.removeNetDest(dst);
>         }
234,239c218
<                 if (output_links.size() > 1) {
<                     // If we are sending this message down more than one link
<                     // (size>1), we need to make a copy of the message so each
<                     // branch can have a different internal destination we need
<                     // to create an unmodified MsgPtr because the MessageBuffer
<                     // enqueue func will modify the message
---
>         assert(msg_dsts.count() == 0);
241,243c220,231
<                     // This magic line creates a private copy of the message
<                     unmodified_msg_ptr = msg_ptr->clone();
<                 }
---
>         // Check for resources - for all outgoing queues
>         bool enough = true;
>         for (int i = 0; i < output_links.size(); i++) {
>             int outgoing = output_links[i];
> 
>             if (!m_out[outgoing][vnet]->areNSlotsAvailable(1, current_time))
>                 enough = false;
> 
>             DPRINTF(RubyNetwork, "Checking if node is blocked ..."
>                     "outgoing: %d, vnet: %d, enough: %d\n",
>                     outgoing, vnet, enough);
>         }
245,256c233,240
<                 // Dequeue msg
<                 buffer->dequeue();
<                 m_pending_message_count[vnet]--;
< 
<                 // Enqueue it - for all outgoing queues
<                 for (int i=0; i<output_links.size(); i++) {
<                     int outgoing = output_links[i];
< 
<                     if (i > 0) {
<                         // create a private copy of the unmodified message
<                         msg_ptr = unmodified_msg_ptr->clone();
<                     }
---
>         // There were not enough resources
>         if (!enough) {
>             scheduleEvent(Cycles(1));
>             DPRINTF(RubyNetwork, "Can't deliver message since a node "
>                     "is blocked\n");
>             DPRINTF(RubyNetwork, "Message: %s\n", (*net_msg_ptr));
>             break; // go to next incoming port
>         }
258,267c242
<                     // Change the internal destination set of the message so it
<                     // knows which destinations this link is responsible for.
<                     net_msg_ptr = msg_ptr.get();
<                     net_msg_ptr->getDestination() =
<                         output_link_destinations[i];
< 
<                     // Enqeue msg
<                     DPRINTF(RubyNetwork, "Enqueuing net msg from "
<                             "inport[%d][%d] to outport [%d][%d].\n",
<                             incoming, vnet, outgoing, vnet);
---
>         MsgPtr unmodified_msg_ptr;
269,270c244,265
<                     m_out[outgoing][vnet]->enqueue(msg_ptr);
<                 }
---
>         if (output_links.size() > 1) {
>             // If we are sending this message down more than one link
>             // (size>1), we need to make a copy of the message so each
>             // branch can have a different internal destination we need
>             // to create an unmodified MsgPtr because the MessageBuffer
>             // enqueue func will modify the message
> 
>             // This magic line creates a private copy of the message
>             unmodified_msg_ptr = msg_ptr->clone();
>         }
> 
>         // Dequeue msg
>         buffer->dequeue(current_time);
>         m_pending_message_count[vnet]--;
> 
>         // Enqueue it - for all outgoing queues
>         for (int i=0; i<output_links.size(); i++) {
>             int outgoing = output_links[i];
> 
>             if (i > 0) {
>                 // create a private copy of the unmodified message
>                 msg_ptr = unmodified_msg_ptr->clone();
271a267,279
> 
>             // Change the internal destination set of the message so it
>             // knows which destinations this link is responsible for.
>             net_msg_ptr = msg_ptr.get();
>             net_msg_ptr->getDestination() = output_link_destinations[i];
> 
>             // Enqeue msg
>             DPRINTF(RubyNetwork, "Enqueuing net msg from "
>                     "inport[%d][%d] to outport [%d][%d].\n",
>                     incoming, vnet, outgoing, vnet);
> 
>             m_out[outgoing][vnet]->enqueue(msg_ptr, current_time,
>                                            m_switch->cyclesToTicks(Cycles(1)));
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/PerfectSwitch.hh network/simple/PerfectSwitch.hh
43a44
> #include "mem/ruby/common/TypeDefines.hh"
87a89
>     void operateMessageBuffer(MessageBuffer *b, int incoming, int vnet);
89c91,92
<     SwitchID m_switch_id;
---
>     const SwitchID m_switch_id;
>     Switch * const m_switch;
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/SimpleLink.cc network/simple/SimpleLink.cc
35,37c35,37
<     // bandwidth multiplier.  The multipiler, in combination with the 
<     // endpoint bandwidth multiplier - message size multiplier ratio, 
<     // determines the link bandwidth in bytes 
---
>     // bandwidth multiplier.  The multipiler, in combination with the
>     // endpoint bandwidth multiplier - message size multiplier ratio,
>     // determines the link bandwidth in bytes
57,59c57,59
<     // bandwidth multiplier.  The multipiler, in combination with the 
<     // endpoint bandwidth multiplier - message size multiplier ratio, 
<     // determines the link bandwidth in bytes 
---
>     // bandwidth multiplier.  The multipiler, in combination with the
>     // endpoint bandwidth multiplier - message size multiplier ratio,
>     // determines the link bandwidth in bytes
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/SimpleLink.hh network/simple/SimpleLink.hh
29,30c29,30
< #ifndef __MEM_RUBY_NETWORK_SIMPLE_LINK_HH__
< #define __MEM_RUBY_NETWORK_SIMPLE_LINK_HH__
---
> #ifndef __MEM_RUBY_NETWORK_SIMPLE_SIMPLELINK_HH__
> #define __MEM_RUBY_NETWORK_SIMPLE_SIMPLELINK_HH__
82c82
< #endif // __MEM_RUBY_NETWORK_SIMPLE_LINK_HH__
---
> #endif //__MEM_RUBY_NETWORK_SIMPLE_SIMPLELINK_HH__
Only in network/simple: .SimpleLink.hh.swp
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/SimpleLink.py network/simple/SimpleLink.py
33c33
< from BasicLink import BasicIntLink, BasicExtLink
---
> from m5.objects.BasicLink import BasicIntLink, BasicExtLink
Only in network/simple: .SimpleLink.py.swp
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/SimpleNetwork.cc network/simple/SimpleNetwork.cc
28a29,30
> #include "mem/ruby/network/simple/SimpleNetwork.hh"
> 
37d38
< #include "mem/ruby/network/simple/SimpleNetwork.hh"
41d41
< #include "mem/ruby/system/System.hh"
47c47,49
<     : Network(p)
---
>     : Network(p), m_buffer_size(p->buffer_size),
>       m_endpoint_bandwidth(p->endpoint_bandwidth),
>       m_adaptive_routing(p->adaptive_routing)
49,57d50
<     m_buffer_size = p->buffer_size;
<     m_endpoint_bandwidth = p->endpoint_bandwidth;
<     m_adaptive_routing = p->adaptive_routing;
< 
<     // Note: the parent Network Object constructor is called before the
<     // SimpleNetwork child constructor.  Therefore, the member variables
<     // used below should already be initialized.
<     m_endpoint_switches.resize(m_nodes);
< 
89,90c82
< SimpleNetwork::makeOutLink(SwitchID src, NodeID dest, BasicLink* link,
<                            LinkDirection direction,
---
> SimpleNetwork::makeExtOutLink(SwitchID src, NodeID dest, BasicLink* link,
102,103d93
< 
<     m_endpoint_switches[dest] = m_switches[src];
108,109c98
< SimpleNetwork::makeInLink(NodeID src, SwitchID dest, BasicLink* link,
<                           LinkDirection direction,
---
> SimpleNetwork::makeExtInLink(NodeID src, SwitchID dest, BasicLink* link,
119,120c108,110
<                                 LinkDirection direction,
<                                 const NetDest& routing_table_entry)
---
>                                 const NetDest& routing_table_entry,
>                                 PortDirection src_outport,
>                                 PortDirection dst_inport)
143,176d132
< SimpleNetwork::checkNetworkAllocation(NodeID id, bool ordered, int network_num)
< {
<     assert(id < m_nodes);
<     assert(network_num < m_virtual_networks);
< 
<     if (ordered) {
<         m_ordered[network_num] = true;
<     }
<     m_in_use[network_num] = true;
< }
< 
< void
< SimpleNetwork::setToNetQueue(NodeID id, bool ordered, int network_num,
<                              std::string vnet_type, MessageBuffer *b)
< {
<     checkNetworkAllocation(id, ordered, network_num);
<     while (m_toNetQueues[id].size() <= network_num) {
<         m_toNetQueues[id].push_back(nullptr);
<     }
<     m_toNetQueues[id][network_num] = b;
< }
< 
< void
< SimpleNetwork::setFromNetQueue(NodeID id, bool ordered, int network_num,
<                                std::string vnet_type, MessageBuffer *b)
< {
<     checkNetworkAllocation(id, ordered, network_num);
<     while (m_fromNetQueues[id].size() <= network_num) {
<         m_fromNetQueues[id].push_back(nullptr);
<     }
<     m_fromNetQueues[id][network_num] = b;
< }
< 
< void
178a135,136
>     Network::regStats();
> 
232,237d189
<             return true;
<         }
<     }
< 
<     for (unsigned int i = 0; i < m_int_link_buffers.size(); ++i) {
<         if (m_int_link_buffers[i]->functionalRead(pkt)) {
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/SimpleNetwork.hh network/simple/SimpleNetwork.hh
59,66c59
<     // sets the queue requested
<     void setToNetQueue(NodeID id, bool ordered, int network_num,
<                        std::string vnet_type, MessageBuffer *b);
<     void setFromNetQueue(NodeID id, bool ordered, int network_num,
<                          std::string vnet_type, MessageBuffer *b);
< 
<     bool isVNetOrdered(int vnet) { return m_ordered[vnet]; }
<     bool validVirtualNetwork(int vnet) { return m_in_use[vnet]; }
---
>     bool isVNetOrdered(int vnet) const { return m_ordered[vnet]; }
69,70c62
<     void makeOutLink(SwitchID src, NodeID dest, BasicLink* link, 
<                      LinkDirection direction, 
---
>     void makeExtOutLink(SwitchID src, NodeID dest, BasicLink* link,
72,73c64
<     void makeInLink(NodeID src, SwitchID dest, BasicLink* link,
<                     LinkDirection direction, 
---
>     void makeExtInLink(NodeID src, SwitchID dest, BasicLink* link,
76,77c67,69
<                           LinkDirection direction, 
<                           const NetDest& routing_table_entry);
---
>                           const NetDest& routing_table_entry,
>                           PortDirection src_outport,
>                           PortDirection dst_inport);
85d76
<     void checkNetworkAllocation(NodeID id, bool ordered, int network_num);
98,102c89,91
<     std::vector<Switch*> m_endpoint_switches;
< 
<     int m_buffer_size;
<     int m_endpoint_bandwidth;
<     bool m_adaptive_routing;    
---
>     const int m_buffer_size;
>     const int m_endpoint_bandwidth;
>     const bool m_adaptive_routing;
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/SimpleNetwork.py network/simple/SimpleNetwork.py
32,34c32,35
< from Network import RubyNetwork
< from BasicRouter import BasicRouter
< from MessageBuffer import MessageBuffer
---
> 
> from m5.objects.Network import RubyNetwork
> from m5.objects.BasicRouter import BasicRouter
> from m5.objects.MessageBuffer import MessageBuffer
44,46d44
<     # int_links do not recycle buffers, so this parameter is not used.
<     # TODO: Move recycle_latency out of MessageBuffers and into controllers
<     recycle_latency = Param.Cycles(0, "")
54c52
<             for i in xrange(self.number_of_virtual_networks):
---
>             for i in range(int(self.number_of_virtual_networks)):
62c60,61
<             # Add message buffers to routers for each internal link connection
---
>             # Add message buffers to routers at the end of each
>             # unidirectional internal link
64,68c63,64
<                 if link.node_a == router:
<                     for i in xrange(self.number_of_virtual_networks):
<                         router_buffers.append(MessageBuffer(ordered = True))
<                 if link.node_b == router:
<                     for i in xrange(self.number_of_virtual_networks):
---
>                 if link.dst_node == router:
>                     for i in range(int(self.number_of_virtual_networks)):
75c71
<                     for i in xrange(self.number_of_virtual_networks):
---
>                     for i in range(int(self.number_of_virtual_networks)):
85,87d80
<     # Ports do not recycle buffers, so this parameter is not used.
<     # TODO: Move recycle_latency out of MessageBuffers and into controllers
<     recycle_latency = Param.Cycles(0, "")
Only in network/simple: .SimpleNetwork.py.swp
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/Switch.cc network/simple/Switch.cc
28a29,30
> #include "mem/ruby/network/simple/Switch.hh"
> 
36d37
< #include "mem/ruby/network/simple/Switch.hh"
72,77d72
< 
<     for (auto& it : in) {
<         if (it != nullptr) {
<             it->setReceiver(this);
<         }
<     }
98,101d92
<         if (out[i] != nullptr) {
<             out[i]->setSender(this);
<         }
< 
106,108d96
< 
<         buffer_ptr->setSender(this);
<         buffer_ptr->setReceiver(this);
127a116,117
>     BasicRouter::regStats();
> 
187,192d176
<     // Access the buffers in the switch for performing a functional read
<     for (unsigned int i = 0; i < m_port_buffers.size(); ++i) {
<         if (m_port_buffers[i]->functionalRead(pkt)) {
<             return true;
<         }
<     }
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/Switch.hh network/simple/Switch.hh
46d45
< #include "mem/protocol/MessageSizeType.hh"
48a48
> #include "mem/ruby/protocol/MessageSizeType.hh"
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/Throttle.cc network/simple/Throttle.cc
28a29,30
> #include "mem/ruby/network/simple/Throttle.hh"
> 
34d35
< #include "mem/ruby/network/simple/Throttle.hh"
36a38
> #include "mem/ruby/network/simple/Switch.hh"
38c40
< #include "mem/ruby/system/System.hh"
---
> #include "mem/ruby/system/RubySystem.hh"
51,61c53,55
<                    ClockedObject *em)
<     : Consumer(em), m_ruby_system(rs)
< {
<     init(node, link_latency, link_bandwidth_multiplier, endpoint_bandwidth);
<     m_sID = sID;
< }
< 
< Throttle::Throttle(RubySystem *rs, NodeID node, Cycles link_latency,
<                    int link_bandwidth_multiplier, int endpoint_bandwidth,
<                    ClockedObject *em)
<     : Consumer(em), m_ruby_system(rs)
---
>                    Switch *em)
>     : Consumer(em), m_switch_id(sID), m_switch(em), m_node(node),
>       m_ruby_system(rs)
63,71d56
<     init(node, link_latency, link_bandwidth_multiplier, endpoint_bandwidth);
<     m_sID = 0;
< }
< 
< void
< Throttle::init(NodeID node, Cycles link_latency,
<                int link_bandwidth_multiplier, int endpoint_bandwidth)
< {
<     m_node = node;
101c86
<         string desc = "[Queue to Throttle " + to_string(m_sID) + " " +
---
>         string desc = "[Queue to Throttle " + to_string(m_switch_id) + " " +
113d97
<     assert(m_units_remaining[vnet] >= 0);
115,116c99,100
<     while (bw_remaining > 0 && (in->isReady() || m_units_remaining[vnet] > 0) &&
<                                 out->areNSlotsAvailable(1)) {
---
>     assert(m_units_remaining[vnet] >= 0);
>     Tick current_time = m_switch->clockEdge();
117a102,104
>     while (bw_remaining > 0 && (in->isReady(current_time) ||
>                                 m_units_remaining[vnet] > 0) &&
>            out->areNSlotsAvailable(1, current_time)) {
120c107
<         if (m_units_remaining[vnet] == 0 && in->isReady()) {
---
>         if (m_units_remaining[vnet] == 0 && in->isReady(current_time)) {
133,134c120,122
<             in->dequeue();
<             out->enqueue(msg_ptr, m_link_latency);
---
>             in->dequeue(current_time);
>             out->enqueue(msg_ptr, current_time,
>                          m_switch->cyclesToTicks(m_link_latency));
147,148c135,137
<     if (bw_remaining > 0 && (in->isReady() || m_units_remaining[vnet] > 0) &&
<                              !out->areNSlotsAvailable(1)) {
---
>     if (bw_remaining > 0 && (in->isReady(current_time) ||
>                              m_units_remaining[vnet] > 0) &&
>         !out->areNSlotsAvailable(1, current_time)) {
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/simple/Throttle.hh network/simple/Throttle.hh
47c47
< #include "mem/ruby/system/System.hh"
---
> #include "mem/ruby/system/RubySystem.hh"
49a50
> class Switch;
56,59c57
<              ClockedObject *em);
<     Throttle(RubySystem *rs, NodeID node, Cycles link_latency,
<              int link_bandwidth_multiplier, int endpoint_bandwidth,
<              ClockedObject *em);
---
>              Switch *em);
63c61
<     { return csprintf("Throttle-%i", m_sID); }
---
>     { return csprintf("Throttle-%i", m_switch_id); }
100c98,99
<     int m_sID;
---
>     const int m_switch_id;
>     Switch *m_switch;
101a101
> 
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/Topology.cc network/Topology.cc
28a29,30
> #include "mem/ruby/network/Topology.hh"
> 
35c37
< #include "mem/ruby/network/Topology.hh"
---
> #include "mem/ruby/network/Network.hh"
49,61c51,56
< // Helper functions based on chapter 29 of Cormen et al.
< void extend_shortest_path(Matrix& current_dist, Matrix& latencies,
<     Matrix& inter_switches);
< Matrix shortest_path(const Matrix& weights, Matrix& latencies,
<     Matrix& inter_switches);
< bool link_is_shortest_path_to_node(SwitchID src, SwitchID next,
<     SwitchID final, const Matrix& weights, const Matrix& dist);
< NetDest shortest_path_to_node(SwitchID src, SwitchID next,
<     const Matrix& weights, const Matrix& dist);
< 
< Topology::Topology(uint32_t num_routers, vector<BasicExtLink *> ext_links,
<                    vector<BasicIntLink *> int_links)
<     : m_number_of_switches(num_routers)
---
> Topology::Topology(uint32_t num_routers,
>                    const vector<BasicExtLink *> &ext_links,
>                    const vector<BasicIntLink *> &int_links)
>     : m_nodes(MachineType_base_number(MachineType_NUM)),
>       m_number_of_switches(num_routers),
>       m_ext_link_vector(ext_links), m_int_link_vector(int_links)
63,67d57
< 
<     // initialize component latencies record
<     m_component_latencies.resize(0);
<     m_component_inter_switches.resize(0);
< 
69,70d58
<     // Must make sure this is called after the State Machine constructors
<     m_nodes = MachineType_base_number(MachineType_NUM);
73,81c61,68
<     if (m_nodes != ext_links.size()) {
<         fatal("m_nodes (%d) != ext_links vector length (%d)\n",
<               m_nodes, ext_links.size());
<     }
< 
<     // analyze both the internal and external links, create data structures
<     // Note that the python created links are bi-directional, but that the
<     // topology and networks utilize uni-directional links.  Thus each 
<     // BasicLink is converted to two calls to add link, on for each direction
---
>     // analyze both the internal and external links, create data structures.
>     // The python created external links are bi-directional,
>     // and the python created internal links are uni-directional.
>     // The networks and topology utilize uni-directional links.
>     // Thus each external link is converted to two calls to addLink,
>     // one for each direction.
>     //
>     // External Links
88,90d74
<         // Store the ExtLink pointers for later
<         m_ext_link_vector.push_back(ext_link);
< 
97,100c81,84
<         //   the first direction is marked: In
<         addLink(ext_idx1, int_idx, ext_link, LinkDirection_In);
<         //   the first direction is marked: Out
<         addLink(int_idx, ext_idx2, ext_link, LinkDirection_Out);
---
>         // ext to int
>         addLink(ext_idx1, int_idx, ext_link);
>         // int to ext
>         addLink(int_idx, ext_idx2, ext_link);
102a87
>     // Internal Links
106,107c91,95
<         BasicRouter *router_a = int_link->params()->node_a;
<         BasicRouter *router_b = int_link->params()->node_b;
---
>         BasicRouter *router_src = int_link->params()->src_node;
>         BasicRouter *router_dst = int_link->params()->dst_node;
> 
>         PortDirection src_outport = int_link->params()->src_outport;
>         PortDirection dst_inport = int_link->params()->dst_inport;
112,113c100,101
<         int a = router_a->params()->router_id + 2*m_nodes;
<         int b = router_b->params()->router_id + 2*m_nodes;
---
>         int src = router_src->params()->router_id + 2*m_nodes;
>         int dst = router_dst->params()->router_id + 2*m_nodes;
115,119c103,104
<         // create the internal uni-directional links in both directions
<         //   the first direction is marked: In
<         addLink(a, b, int_link, LinkDirection_In);
<         //   the second direction is marked: Out
<         addLink(b, a, int_link, LinkDirection_Out);
---
>         // create the internal uni-directional link from src to dst
>         addLink(src, dst, int_link, src_outport, dst_inport);
132c117
<         max_switch_id = max(max_switch_id, src_dest.second);        
---
>         max_switch_id = max(max_switch_id, src_dest.second);
136d120
<     Matrix topology_weights;
138,157c122,127
<     topology_weights.resize(num_switches);
<     m_component_latencies.resize(num_switches);
<     m_component_inter_switches.resize(num_switches);
< 
<     for (int i = 0; i < topology_weights.size(); i++) {
<         topology_weights[i].resize(num_switches);
<         m_component_latencies[i].resize(num_switches);
<         m_component_inter_switches[i].resize(num_switches);
< 
<         for (int j = 0; j < topology_weights[i].size(); j++) {
<             topology_weights[i][j] = INFINITE_LATENCY;
< 
<             // initialize to invalid values
<             m_component_latencies[i][j] = -1;
< 
<             // initially assume direct connections / no intermediate
<             // switches between components
<             m_component_inter_switches[i][j] = 0;
<         }
<     }
---
>     Matrix topology_weights(num_switches,
>             vector<int>(num_switches, INFINITE_LATENCY));
>     Matrix component_latencies(num_switches,
>             vector<int>(num_switches, -1));
>     Matrix component_inter_switches(num_switches,
>             vector<int>(num_switches, 0));
171c141
<         m_component_latencies[src][dst] = link->m_latency;
---
>         component_latencies[src][dst] = link->m_latency;
174c144
<         
---
> 
176,177c146,148
<     Matrix dist = shortest_path(topology_weights, m_component_latencies,
<         m_component_inter_switches);
---
>     Matrix dist = shortest_path(topology_weights, component_latencies,
>                                 component_inter_switches);
> 
191,192c162,164
< Topology::addLink(SwitchID src, SwitchID dest, BasicLink* link, 
<                   LinkDirection dir)
---
> Topology::addLink(SwitchID src, SwitchID dest, BasicLink* link,
>                   PortDirection src_outport_dirn,
>                   PortDirection dst_inport_dirn)
196c168
<     
---
> 
202d173
<     link_entry.direction = dir;
203a175,176
>     link_entry.src_outport_dirn = src_outport_dirn;
>     link_entry.dst_inport_dirn  = dst_inport_dirn;
216c189
<     LinkEntry link_entry;    
---
>     LinkEntry link_entry;
222,223c195,196
<         net->makeInLink(src, dest - (2 * m_nodes), link_entry.link,
<                         link_entry.direction, routing_table_entry);
---
>         net->makeExtInLink(src, dest - (2 * m_nodes), link_entry.link,
>                         routing_table_entry);
230,231c203,204
<         net->makeOutLink(src - (2 * m_nodes), node, link_entry.link,
<                          link_entry.direction, routing_table_entry);
---
>         net->makeExtOutLink(src - (2 * m_nodes), node, link_entry.link,
>                          routing_table_entry);
238,239c211,214
<                               link_entry.link, link_entry.direction,
<                               routing_table_entry);
---
>                               link_entry.link,
>                               routing_table_entry,
>                               link_entry.src_outport_dirn,
>                               link_entry.dst_inport_dirn);
246,247c221,222
< extend_shortest_path(Matrix& current_dist, Matrix& latencies,
<     Matrix& inter_switches)
---
> Topology::extend_shortest_path(Matrix &current_dist, Matrix &latencies,
>     Matrix &inter_switches)
284c259,260
< shortest_path(const Matrix& weights, Matrix& latencies, Matrix& inter_switches)
---
> Topology::shortest_path(const Matrix &weights, Matrix &latencies,
>                         Matrix &inter_switches)
292,293c268,270
< link_is_shortest_path_to_node(SwitchID src, SwitchID next, SwitchID final,
<     const Matrix& weights, const Matrix& dist)
---
> Topology::link_is_shortest_path_to_node(SwitchID src, SwitchID next,
>                                         SwitchID final, const Matrix &weights,
>                                         const Matrix &dist)
299,300c276,277
< shortest_path_to_node(SwitchID src, SwitchID next, const Matrix& weights,
<     const Matrix& dist)
---
> Topology::shortest_path_to_node(SwitchID src, SwitchID next,
>                                 const Matrix &weights, const Matrix &dist)
diff -r /mnt/d/source/github/sim/gem5-gpu/gem5/src/mem/ruby/network/Topology.hh network/Topology.hh
47d46
< #include "mem/protocol/LinkDirection.hh"
49a49
> #include "mem/ruby/protocol/LinkDirection.hh"
54a55
> typedef std::string PortDirection;
56c57
< struct LinkEntry 
---
> struct LinkEntry
59c60,61
<     LinkDirection direction;
---
>     PortDirection src_outport_dirn;
>     PortDirection dst_inport_dirn;
67,68c69,70
<     Topology(uint32_t num_routers, std::vector<BasicExtLink *> ext_links,
<              std::vector<BasicIntLink *> int_links);
---
>     Topology(uint32_t num_routers, const std::vector<BasicExtLink *> &ext_links,
>              const std::vector<BasicIntLink *> &int_links);
74c76
<   protected:
---
>   private:
76c78,79
<                  LinkDirection dir);
---
>                  PortDirection src_outport_dirn = "",
>                  PortDirection dest_inport_dirn = "");
80,81c83,97
<     NodeID m_nodes;
<     uint32_t m_number_of_switches;
---
>     // Helper functions based on chapter 29 of Cormen et al.
>     void extend_shortest_path(Matrix &current_dist, Matrix &latencies,
>                               Matrix &inter_switches);
> 
>     std::vector<std::vector<int>> shortest_path(const Matrix &weights,
>             Matrix &latencies, Matrix &inter_switches);
> 
>     bool link_is_shortest_path_to_node(SwitchID src, SwitchID next,
>             SwitchID final, const Matrix &weights, const Matrix &dist);
> 
>     NetDest shortest_path_to_node(SwitchID src, SwitchID next,
>                                   const Matrix &weights, const Matrix &dist);
> 
>     const uint32_t m_nodes;
>     const uint32_t m_number_of_switches;
85,87d100
< 
<     Matrix m_component_latencies;
<     Matrix m_component_inter_switches;
